// SPDX-FileCopyrightText: 2023 Open Salamander Authors
// SPDX-License-Identifier: GPL-2.0-or-later
// CommentsTranslationProject: TRANSLATED

#pragma once

// ****************************************************************************
// CONSTANTS
// ****************************************************************************

// chosen limits for FTP addresses
#define HOST_MAX_SIZE 201         // host name of the FTP server
#define USERPASSACCT_MAX_SIZE 101 // maximum of USER_MAX_SIZE, PASSWORD_MAX_SIZE, and ACCOUNT_MAX_SIZE
#define USER_MAX_SIZE 101         // user name (if changed, beware of USERPASSACCT_MAX_SIZE)
#define PASSWORD_MAX_SIZE 101     // password (if changed, beware of USERPASSACCT_MAX_SIZE)
#define ACCOUNT_MAX_SIZE 101      // account info (see FTP command "ACCT") (if changed, beware of USERPASSACCT_MAX_SIZE)
#define FTP_MAX_PATH 301          // path on the FTP server (NOTE: this is not the limit for CFileData::Name - that is up to MAX_PATH-5 characters - Salamander limit)
#define FTP_USERPART_SIZE 610     // limit for the size of the user-part path (format: "ftp:" + "//user@host:port/path")
#define BOOKMSRVTYPE_MAX_SIZE 101 // maximum of BOOKMARKNAME_MAX_SIZE and SERVERTYPE_MAX_SIZE
#define BOOKMARKNAME_MAX_SIZE 101 // bookmark name on the FTP server (e.g. in the Connect dialog) (if changed, beware of BOOKMSRVTYPE_MAX_SIZE)
#define SERVERTYPE_MAX_SIZE 101   // FTP server type name (e.g. in Connect/Advanced...) (if changed, beware of BOOKMSRVTYPE_MAX_SIZE)
#define FTPCOMMAND_MAX_SIZE 301   // max length of an FTP command (used by the "Send FTP Command" command + "Adv. connect dlg: Command for listing" + max length of a command generated by the proxy script)
#define AUTODETCOND_MAX_SIZE 1001 // max length of the condition used when autodetecting the "server type"
#define PARSER_MAX_SIZE 20481     // max length of the listing parser (currently 20KB)
#define STC_ID_MAX_SIZE 101       // Server Type Columns: max length of the ID
#define STC_NAME_MAX_SIZE 101     // Server Type Columns: max length of the name
#define STC_DESCR_MAX_SIZE 201    // Server Type Columns: max length of the description
#define STC_EMPTYVAL_MAX_SIZE 101 // Server Type Columns: max length of the empty value string
#define PROXYSRVNAME_MAX_SIZE 101 // proxy server name (see CFTPProxyServer::ProxyName)
#define PROXYSCRIPT_MAX_SIZE 2049 // max length of a proxy script (currently 2KB) (see CFTPProxyServer::ProxyScript)

// max length of the string that stores a Server Type Column
#define STC_MAXCOLUMNSTR (1 + 2 * (STC_ID_MAX_SIZE + STC_NAME_MAX_SIZE + STC_DESCR_MAX_SIZE + STC_EMPTYVAL_MAX_SIZE - 4) + 10 + 10 + 2 + 1 + 8)

// history sizing
#define COMMAND_HISTORY_SIZE 10     // max number of remembered items for the "Send FTP Command" history
#define HOSTADDRESS_HISTORY_SIZE 30 // max number of remembered items for the history of FTP server addresses in the Connect to FTP Server dialog
#define INITIALPATH_HISTORY_SIZE 30 // max number of remembered items for the initial path history on the FTP server in the Connect to FTP Server dialog

// number of standard names and descriptions for columns in "server types"
#define STC_STD_NAMES_COUNT 37

// commands in the plugin menu:
#define FTPCMD_CONNECTFTPSERVER 1   // connect to FTP server...
#define FTPCMD_DISCONNECT 2         // disconnect...
#define FTPCMD_ADDBOOKMARK 3        // add bookmark...
#define FTPCMD_CLOSECONNOTIF 4      // not in the menu (helper command): checks whether the user has already been informed about the closure of the "control connection"
#define FTPCMD_SHOWLOGS 5           // active panel: show logs...
#define FTPCMD_SENDFTPCOMMAND 6     // send FTP command...
#define FTPCMD_ORGANIZEBOOKMARKS 7  // organize bookmarks...
#define FTPCMD_CHANGETGTPANELPATH 8 // not in the menu (helper command): change the path in the other panel
#define FTPCMD_SHOWRAWLISTING 9     // show raw listing...
#define FTPCMD_TRMODEAUTO 10        // transfer mode/automatic
#define FTPCMD_TRMODEASCII 11       // transfer mode/ascii
#define FTPCMD_TRMODEBINARY 12      // transfer mode/binary
#define FTPCMD_REFRESHPATH 13       // refresh current path
#define FTPCMD_CANCELOPERATION 14   // not in the menu (helper command): cancel the FTP operation
#define FTPCMD_RETURNCONNECTION 15  // not in the menu (helper command): return the connection from the worker to the panel
#define FTPCMD_REFRESHLEFTPANEL 16  // not in the menu (helper command): hard refresh of the left panel
#define FTPCMD_REFRESHRIGHTPANEL 17 // not in the menu (helper command): hard refresh of the right panel
#define FTPCMD_DISCONNECT_F12 18    // disconnect... (through Salamander's Disconnect - F12 button)
#define FTPCMD_ACTIVWELCOMEMSG 19   // not in the menu (helper command): activates the welcome message (only if it exists; if an error message box is shown it stays inactive)
#define FTPCMD_LISTHIDDENFILES 20   // list hidden files (unix)
#define FTPCMD_TRMODESUBMENU 21     // transfer mode submenu (if disabled, help via Shift+F1 is delivered for the submenu)
#define FTPCMD_SHOWLOGSLEFT 22      // left panel: show logs...
#define FTPCMD_SHOWLOGSRIGHT 23     // right panel: show logs...
#define FTPCMD_SHOWCERT 24          // show certificate (SSL)...

// commands in the change drive menu plugin context menu:
#define CHNGDRV_CONNECTFTPSERVER 1  // connect to FTP server...
#define CHNGDRV_DISCONNECT 2        // disconnect...
#define CHNGDRV_OPENDETACHED 3      // open...
#define CHNGDRV_ADDBOOKMARK 4       // add bookmark...
#define CHNGDRV_SHOWLOG 5           // show log
#define CHNGDRV_SENDFTPCOMMAND 6    // send FTP command...
#define CHNGDRV_ORGANIZEBOOKMARKS 7 // organize bookmarks...
#define CHNGDRV_SHOWLOGS 8          // show logs...
#define CHNGDRV_SHOWRAWLISTING 9    // show raw listing...
#define CHNGDRV_LISTHIDDENFILES 10  // list hidden files
#define CHNGDRV_SHOWCERT 11         // show certificate...

// ****************************************************************************
// GLOBAL VARIABLES
// ****************************************************************************

// global data
extern HINSTANCE DLLInstance; // handle to the SPL - language-independent resources
extern HINSTANCE HLanguage;   // handle to the SLG - language-dependent resources
extern HICON FTPIcon;         // (16x16) FTP icon
extern HICON FTPLogIcon;      // (16x16) icon of the FTP Logs dialog
extern HICON FTPLogIconBig;   // large (32x32) icon of the FTP Logs dialog
extern HICON FTPOperIcon;     // (16x16) icon of the operation dialog
extern HICON FTPOperIconBig;  // large (32x32) icon of the operation dialog
extern HCURSOR DragCursor;    // cursor for the drag&drop list box in the Connect dialog
extern HFONT FixedFont;       // font for the Welcome Message dialog (fixed so text layout works better)
extern HFONT SystemFont;      // environment font (dialogs, wait window, etc.)
extern HICON WarningIcon;     // small (16x16) "warning" icon for the operation dialog

// generic Salamander interface - valid from startup until the plug-in is closed
extern CSalamanderGeneralAbstract* SalamanderGeneral;

// ZLIB compression/decompression interface;
extern CSalamanderZLIBAbstract* SalZLIB;

// interface providing customized Windows controls used in Salamander
extern CSalamanderGUIAbstract* SalamanderGUI;

// FS name assigned by Salamander after the plug-in is loaded
extern char AssignedFSName[MAX_PATH];
extern int AssignedFSNameLen; // length of AssignedFSName

// FS name for FTP over SSL (FTPS) assigned by Salamander after the plug-in loads
extern char AssignedFSNameFTPS[MAX_PATH];
extern int AssignedFSNameIndexFTPS; // index of AssignedFSNameFTPS
extern int AssignedFSNameLenFTPS;   // length of AssignedFSNameFTPS

// pointers to the lower/upper case mapping tables
extern unsigned char* LowerCase;
extern unsigned char* UpperCase;

// frequently used error message
extern const char* LOW_MEMORY;

extern const char* SAVEBITS_CLASSNAME; // class for CWaitWindow

extern int GlobalShowLogUID;      // UID of the log that FTPCMD_SHOWLOGS should show (-1 == none)
extern int GlobalDisconnectPanel; // panel for which disconnect is called (-1 == active panel - source)

extern CThreadQueue AuxThreadQueue; // queue of all auxiliary threads

extern BOOL WindowsVistaAndLater; // Windows Vista or later from the NT line

// global variables for the FTPCMD_CHANGETGTPANELPATH command
extern int TargetPanelPathPanel;
extern char TargetPanelPath[MAX_PATH];

extern char UserDefinedSuffix[100]; // preloaded string for marking user-defined "server types"

extern const char* LIST_CMD_TEXT;   // text of the "LIST" FTP command
extern const char* NLST_CMD_TEXT;   // text of the "NLST" FTP command
extern const char* LIST_a_CMD_TEXT; // text of the "LIST -a" FTP command

extern int SortByExtDirsAsFiles; // current value of Salamander configuration variable SALCFG_SORTBYEXTDIRSASFILES
extern int InactiveBeepWhenDone; // current value of Salamander configuration variable SALCFG_MINBEEPWHENDONE

// global variables where I store pointers to Salamander's global variables
extern const CFileData** TransferFileData;
extern int* TransferIsDir;
extern char* TransferBuffer;
extern int* TransferLen;
extern DWORD* TransferRowData;
extern CPluginDataInterfaceAbstract** TransferPluginDataIface;
extern DWORD* TransferActCustomData;

// constants used in both ftp2.cpp and ftp.cpp
extern const char* CONFIG_SERVERTYPES;
extern const char* CONFIG_STNAME;
extern const char* CONFIG_STADCOND;
extern const char* CONFIG_STCOLUMNS;
extern const char* CONFIG_STRULESFORPARS;
extern const char* CONFIG_FTPSERVERLIST;
extern const char* CONFIG_FTPPROXYLIST;
extern const char* CONFIG_FTPPRXUID;
extern const char* CONFIG_FTPPRXNAME;
extern const char* CONFIG_FTPPRXTYPE;
extern const char* CONFIG_FTPPRXHOST;
extern const char* CONFIG_FTPPRXPORT;
extern const char* CONFIG_FTPPRXUSER;
extern const char* CONFIG_FTPPRXPASSWD_OLD;
extern const char* CONFIG_FTPPRXPASSWD_SCRAMBLED;
extern const char* CONFIG_FTPPRXPASSWD_ENCRYPTED;

extern const char* CONFIG_FTPPRXSCRIPT;

// ****************************************************************************
// GLOBAL FUNCTIONS
// ****************************************************************************

// helper functions
BOOL InitFS();
void ReleaseFS();

// loads from this SPL module's resources a string with ID 'resID', returns a pointer to
// the string (stored in a global cyclic buffer)
char* LoadStr(int resID);

// execution of the "Connect FTP Server" command - called by Alt+F1/F2, in the Drive bars, and from the plugin menu
void ConnectFTPServer(HWND parent, int panel);

// execution of the "Organize Bookmarks" command - called by Alt+F1/F2, in the Drive bars, and from the plugin menu
void OrganizeBookmarks(HWND parent);

// copies the contents of 'newStr' into 'str', reallocates 'str' if needed; sets 'err' (if not NULL) to TRUE
// on low memory; if 'clearMem' is TRUE, wipes memory that stops being used (due to passwords)
void UpdateStr(char*& str, const char* newStr, BOOL* err = NULL, BOOL clearMem = FALSE);

// scrambling and the reverse process used for storing passwords in the registry
void ScramblePassword(char* password);
void UnscramblePassword(char* password);

// if 'str'==NULL, returns an empty string instead of NULL
char* HandleNULLStr(char* str);

// if 's' is an empty string, returns NULL, otherwise returns 's'
const char* GetStrOrNULL(const char* s);

// returns TRUE if 's' is neither NULL nor ""
BOOL IsNotEmptyStr(const char* s);

// allocates a copy of the 'password' buffer of size 'size', returns a pointer to it
BYTE* DupEncryptedPassword(const BYTE* password, int size);
void UpdateEncryptedPassword(BYTE** password, int* passwordSize, const BYTE* newPassword, int newPasswordSize);

// returns the path to Documents (CSIDL_PERSONAL); 'initDir' is a buffer at least MAX_PATH in size;
// returns an empty string on failure
void GetMyDocumentsPath(char* initDir);

// returns 'typeName' in a user-visible form (with an extension, without '*');
// 'buf'+'bufSize' define a helper buffer (a pointer to it may be returned),
// a reasonable buffer size is (SERVERTYPE_MAX_SIZE + 101)
char* GetTypeNameForUser(char* typeName, char* buf, int bufSize);

// loads from resources the standard column name identified by 'id' (columns for
// "server type" - solution for translating user-defined parsers);
// returns TRUE if 'id' is known
BOOL LoadStdColumnStrName(char* buf, int bufSize, int id);

// loads from resources the standard column description identified by 'id' (columns for
// "server type" - solution for translating user-defined parsers)
// returns TRUE if 'id' is known
BOOL LoadStdColumnStrDescr(char* buf, int bufSize, int id);

// RegEdit cannot import strings with EOLs from .reg files -> replace EOLs (CRLF with '|',
// LF with '!' and CR with '$');
// converts a regular string to a registry string; returns FALSE if the result
// did not fit into the buffer
BOOL ConvertStringTxtToReg(char* buf, int bufSize, const char* txtStr);

// RegEdit cannot import strings with EOLs from .reg files -> replace EOLs (CRLF with '|',
// LF with '!' and CR with '$');
// converts a registry string to a regular string; returns FALSE if the result
// did not fit into the buffer
BOOL ConvertStringRegToTxt(char* buf, int bufSize, const char* regStr);

// synchronized counter: "time" of listing start and changes in upload listings;
// returns the incremented counter in a critical section - the first call returns value 1
DWORD IncListingCounter();

// returns the first window in the GetParent() chain that is not a child or has no parent (GetParent() returns NULL for it)
HWND FindPopupParent(HWND wnd);

// loads the scrambled/encrypted/old password
void LoadPassword(HKEY regKey, CSalamanderRegistryAbstract* registry, const char* oldPwdName, const char* scrambledPwdName,
                  const char* encryptedPwdName, BYTE** encryptedPassword, int* encryptedPasswordSize);

// shared code for EncryptPasswords
// encrypts the stored password using AES (encrypt==TRUE) or the scrambled method (encrypt==FALSE)
// returns FALSE if the AES-encrypted password could not be decrypted, otherwise returns TRUE
BOOL EncryptPasswordAux(BYTE** encryptedPassword, int* encryptedPasswordSize, BOOL savePassword, BOOL encrypt);

//
// ****************************************************************************
// CServerTypeList
//

#define INT64_EMPTYNUMBER 0x8000000000000000 // smallest 64-bit int number (-9223372036854775808)

// column types for "server type"
enum CSrvTypeColumnTypes
{
    stctNone, // 0, uninitialized
    // standard columns using standard CFileData fields
    stctName, // 1, name
    stctExt,  // 2, extension appended to the name (without stctName it makes no sense)
    stctSize, // 3, size (UNSIGNED INT64) - default empty value in the column is "0" + directories always have value "0" and the panel shows "DIR"
    stctDate, // 4, date (NOTE: CFileData stores UTC time - requires a local->UTC conversion) - default empty value in the column is "1.1.1602" (adjusted according to regional settings)
    stctTime, // 5, time (NOTE: CFileData stores UTC time - requires a local->UTC conversion) - default empty value in the column is "0:00:00" (adjusted according to regional settings)
    stctType, // 6, file type description (works only if 'stctExt' is present)
    // general columns stored outside CFileData (attached before CFileData::PluginData)
    // NOTE: numbering must match 'stctFirstGeneral'
    stctGeneralText,                    // 7, string type - default empty value in the column is ""
    stctGeneralDate,                    // 8, date type (treated as local time) - default empty value in the column is "" (if CFTPDate::Day equals 0)
    stctGeneralTime,                    // 9, time type (treated as local time) - default empty value in the column is "" (if CFTPTime::Hour equals 24)
    stctGeneralNumber,                  // 10, number type (INT64, displayed similar to file size - e.g. "1 234 567") - default empty value in the column is "" (if it equals INT64_EMPTYNUMBER)
    stctLastItem,                       // 11, helper value: only for load testing
    stctFirstGeneral = stctGeneralText, // 7, first "general" type (these types can be reused within one server type unlike the others)
};

// loads the type description from resources; returns TRUE if 'type' is known (valid)
BOOL GetColumnTypeName(char* buf, int bufSize, CSrvTypeColumnTypes type);

// generates the empty value string according to 'type'; returns TRUE if 'type' is known (valid)
BOOL GetColumnEmptyValueForType(char* buf, int bufSize, CSrvTypeColumnTypes type);

// extracts and verifies the empty value from the 'empty' string (it may also be NULL - standard value) according to
// 'type'; returns TRUE if the value is OK; values are returned in various ways: strings are returned directly as 'empty'
// (NOTE the mapping NULL->""), unsigned numbers are returned in 'qwVal' (if not NULL), signed numbers
// are returned in 'int64Val' (if not NULL), times and dates are in the respective parts (separated) of
// the 'stVal' structure (if not NULL); if 'skipDateCheck' is TRUE, the date validity is not tested
// (time-consuming)
BOOL GetColumnEmptyValue(const char* empty, CSrvTypeColumnTypes type, CQuadWord* qwVal,
                         __int64* int64Val, SYSTEMTIME* stVal, BOOL skipDateCheck);

class CSrvTypeColWidths
{
protected:
    int Links; // number of CSrvTypeColumn objects using this object (they have a pointer to it in CSrvTypeColumn::ColWidths)

public:
    int FixedWidth; // LO/HI-WORD: left/right panel: 0 = elastic column (width based on the widest text), 1 = fixed width (equal to Width)
    int Width;      // LO/HI-WORD: left/right panel: column width when LO/HI-WORD(FixedWidth)==1

public:
    CSrvTypeColWidths()
    {
        Links = 1;
        FixedWidth = 0; // we prefer elastic columns
        Width = 0;      // minimal width (adjusted automatically according to the column name)
    }

    // links one CSrvTypeColumn that uses this object; returns a pointer to this object
    CSrvTypeColWidths* AddRef()
    {
        Links++;
        return (CSrvTypeColWidths*)this;
    }

    // unlinks one CSrvTypeColumn that uses this object; returns TRUE if it was the last one
    // - in that case this object needs to be deallocated
    BOOL Release() { return --Links == 0; }
};

struct CSrvTypeColumn
{
public:
    BOOL Visible;                 // TRUE if the column should be visible in the panel
    char* ID;                     // column identifier for the parser (max. STC_ID_MAX_SIZE-1 characters)
    int NameID;                   // string identifier for the name (-1 = use a non-standard (non-translated) name - see 'NameStr')
    char* NameStr;                // string of the non-standard (non-translated) name (if NameID is not -1, this is NULL) (max. STC_NAME_MAX_SIZE-1 characters)
    int DescrID;                  // string identifier for the header description in the panel (-1 = use a non-standard (non-translated) one - see 'DescrStr')
    char* DescrStr;               // string of the non-standard (non-translated) description (if DescrID is not -1, this is NULL) (max. STC_DESCR_MAX_SIZE-1 characters)
    CSrvTypeColumnTypes Type;     // type of values in the column
    char* EmptyValue;             // value to use when no value is parsed - string (each column type has different syntax; NULL == standard empty value (0, "", 1.1.1602, etc.)) (max. STC_EMPTYVAL_MAX_SIZE-1 characters)
    BOOL LeftAlignment;           // column alignment (meaningful only for Type >= stctFirstGeneral): TRUE = left, FALSE = right
    CSrvTypeColWidths* ColWidths; // link to the FixedWidth+Width pair for this column (these data must be shared among all copies of the column, hence this "smart pointer")

public:
    CSrvTypeColumn(CSrvTypeColWidths* colWidths = NULL);
    ~CSrvTypeColumn();

    BOOL IsGood() { return ColWidths != NULL; }

    // loads column data from an object (the structure must be new)
    void LoadFromObj(CSrvTypeColumn* copyFrom);

    // loads column data from a string (the structure must be new);
    // returns success of the operation
    BOOL LoadFromStr(const char* str);

    // stores the data to buffer 'buf' of size 'bufSize'; returns FALSE only if the data
    // do not fit into the buffer
    BOOL SaveToStr(char* buf, int bufSize, BOOL ignoreColWidths = FALSE);

    // allocates a copy of the structure, returns NULL on error
    CSrvTypeColumn* MakeCopy();

    // sets the structure
    void Set(BOOL visible, char* id, int nameID, char* nameStr, int descrID,
             char* descrStr, CSrvTypeColumnTypes type, char* emptyValue,
             BOOL leftAlignment, int fixedWidth, int width);

protected:
    // helper method: finds how many bytes are needed to store the string 'str' into the allocated
    // string in SaveToAllocatedStr (looks for escape sequences, etc.)
    int SaveStrLen(const char* str);

    // helper method: stores the string 'str' into the allocated string in SaveToAllocatedStr; 's' is
    // the current position in the allocated string; if 'addComma' is TRUE, it also stores the ',' character
    void SaveStr(char** s, const char* str, BOOL addComma);

    // helper method: reads one string from 'str' for LoadFromStr (processes escape sequences,
    // skips the trailing ',' - returns the position of the next record in 'str'); returns the allocated
    // resulting string in 'result'; if 'limit' is not -1, it is the max number of characters in the resulting
    // string (without the null terminator); returns FALSE on allocation error, otherwise TRUE
    BOOL LoadStr(const char** str, char** result, int limit);
};

// verifies whether the column list is valid (contains a visible Name column at position one
// + the Ext column is visible and can be only at position two + variable names are
// unique and non-empty + column names and descriptions are non-empty + except for the "general/any" type
// the types in the column list are not repeated + the empty value has a permitted
// format according to the column type); returns TRUE if the list is valid, otherwise returns FALSE and
// in 'errResID' (if not NULL) the ID of the error description in resources
BOOL ValidateSrvTypeColumns(TIndirectArray<CSrvTypeColumn>* columns, int* errResID);

// returns TRUE if the identifier is OK, otherwise returns FALSE and in 'errResID' (if not NULL)
// returns the ID of the error description in resources
BOOL IsValidIdentifier(const char* s, int* errResID);

class CFTPAutodetCondNode;
class CFTPParser;

struct CServerType
{
    // server type name (max. SERVERTYPE_MAX_SIZE-1 characters); if the name starts with '*',
    // it is a "user defined server type" - '*' is skipped when displayed and a suffix is added,
    //
    // description of adding/updating new server types (for a new version of the FTP Client) see ftp/servers/todo.txt
    //
    char* TypeName;
    char* AutodetectCond;                   // condition used for autodetection (max. AUTODETCOND_MAX_SIZE-1 characters); NULL = always true
    TIndirectArray<CSrvTypeColumn> Columns; // definition of columns for parsing and for the panel
    char* RulesForParsing;                  // rules for parsing listings (max. PARSER_MAX_SIZE-1 characters); NULL = empty

    CFTPAutodetCondNode* CompiledAutodetCond; // if not NULL, this is the compiled current version of AutodetectCond
    CFTPParser* CompiledParser;               // if not NULL, this is the compiled current version of RulesForParsing+Columns

    // !!! NOTE: when adding a new variable it is necessary to update all structure methods !!!

    // helper variable for listing parser autodetection - no need to initialize/copy, etc.
    BOOL ParserAlreadyTested; // TRUE if this server type has already been tried on the listing (unsuccessfully)

    CServerType() : Columns(5, 5) { Init(); }
    ~CServerType() { Release(); }

    void Init();    // initializes all object variables
    void Release(); // releases and initializes all object variables

    // sets the structure, returns FALSE on error
    BOOL Set(const char* typeName, const char* autodetectCond, int columnsCount,
             const char* columnsStr[], const char* rulesForParsing);

    // sets the structure (except for 'typeName' it takes everything from 'copyFrom'), returns FALSE on error
    BOOL Set(const char* typeName, CServerType* copyFrom);

    // loads the structure, returns TRUE if the item is valid (should be added to the list)
    BOOL Load(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);
    // saves the structure
    void Save(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);

    // allocates a copy of the structure, returns NULL on error
    CServerType* MakeCopy();

    // writes the object to a file; 'file' is a file opened for writing; returns a Windows error code
    // (NO_ERROR == completed successfully); does not show any message boxes
    DWORD ExportToFile(HANDLE file);

    // loads data from a file; 'file' is a file opened for reading; returns operation success;
    // in 'err' (must not be NULL) returns the Windows error (NO_ERROR == no read error occurred);
    // in 'errResID' (must not be NULL) returns the string ID describing the error (0 == no error)
    BOOL ImportFromFile(HANDLE file, DWORD* err, int* errResID);
};

class CServerTypeList : public TIndirectArray<CServerType>
{
public:
    CServerTypeList() : TIndirectArray<CServerType>(10, 10) {}

    // adds a server type to the list
    BOOL AddServerType(const char* typeName, const char* autodetectCond, int columnsCount,
                       const char* columnsStr[], const char* rulesForParsing);

    // adds a server type to the list
    BOOL AddServerType(const char* typeName, CServerType* copyFrom);

    // adds names to the combo box + returns the index of type 'serverType' in 'index' (if
    // not found, returns 'index'==-1); 'serverType' may also be NULL (returns 'index'==-1)
    void AddNamesToCombo(HWND combo, const char* serverType, int& index);

    // adds names to the list box
    void AddNamesToListbox(HWND listbox);

    // loads the list
    void Load(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);
    // saves the list
    void Save(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);

    // copies (allocates and transfers data) all items from the 'list';
    // returns TRUE if everything succeeded
    BOOL CopyItemsFrom(CServerTypeList* list);

    // returns TRUE if the list already contains the name 'typeName' (regardless of "user defined");
    // if 'exclude' is not NULL, it is an item to exclude from the search (used when renaming so
    // the item being renamed is not found); in 'index' (if not NULL)
    // returns the index of the found item (-1 if the item is not found)
    BOOL ContainsTypeName(const char* typeName, CServerType* exclude, int* index = NULL);
};

//
// ****************************************************************************
// CFTPServerList
//

struct CFTPServer
{
    char* ItemName;                  // bookmark name (for the Bookmarks list box in the Connect dialog) (max. BOOKMARKNAME_MAX_SIZE-1 characters)
    char* Address;                   // host/IP (max. HOST_MAX_SIZE-1 characters)
    char* InitialPath;               // remote path (may be empty or NULL) (max. FTP_MAX_PATH-1 characters)
    int AnonymousConnection;         // TRUE = anonymous login, FALSE = UserName and Password apply
    char* UserName;                  // user name; if empty (or NULL) and not an anonymous login, ask the user (max. USER_MAX_SIZE-1 characters)
    BYTE* EncryptedPassword;         // password; if empty (or NULL) and not an anonymous login, ask the user (max. PASSWORD_MAX_SIZE-1 characters)
    int EncryptedPasswordSize;       // number of bytes stored in EncryptedPassword
    int SavePassword;                // TRUE = password should be stored on media (registry/config file)
    int ProxyServerUID;              // proxy server: -2 = default, -1 = not used, otherwise the proxy server UID from Config.FTPProxyServerList
    char* TargetPanelPath;           // if not NULL or "", the target path in the panel should be set (max. MAX_PATH-1 characters)
    char* ServerType;                // server type (for listing) - NULL == auto-detect, otherwise a textual name (format see CServerType::TypeName; the server list will gradually expand) (max. SERVERTYPE_MAX_SIZE-1 characters)
    char* ListCommand;               // command for listing - NULL == LIST_CMD_TEXT, otherwise the command text
    int TransferMode;                // 0 - default, 1 - binary, 2 - ascii, 3 - auto (uses Config.ASCIIFileMasks)
    int Port;                        // port of the server we connect to (standard FTP port is IPPORT_FTP)
    int UsePassiveMode;              // 0 - PORT mode, 1 - PASV mode, 2 - according to configuration (Config.PassiveMode)
    int KeepConnectionAlive;         // keep connection alive: 0 - no, 1 - yes (own configuration), 2 - according to configuration (Config.KeepAlive)
    int KeepAliveSendEvery;          // only for KeepConnectionAlive==1: how often to send keep-alive commands
    int KeepAliveStopAfter;          // only for KeepConnectionAlive==1: when to stop sending keep-alive commands
    int KeepAliveCommand;            // only for KeepConnectionAlive==1: command for keep-alive (0-NOOP, 1-PWD, 2-NLST, 3-LIST)
    int UseMaxConcurrentConnections; // 1 = use the MaxConcurrentConnections limit; 2 = default limit, 0 = no limit
    int MaxConcurrentConnections;    // max number of concurrent connections to the server (control+data counts as one connection)
    int UseServerSpeedLimit;         // 1 = use the ServerSpeedLimit limit; 2 = default limit, 0 = no limit
    double ServerSpeedLimit;         // total speed limit for this server
    int UseListingsCache;            // cache for viewed files and listings: 2 = default setting, 1 = use cache, 0 = do not use cache
    char* InitFTPCommands;           // list of FTP commands to send to the server immediately after connecting
    int EncryptControlConnection;    // 0 - no, 1 - yes
    int EncryptDataConnection;       // 0 - no, 1 - yes
    int CompressData;                // 0 - no; 1-9 - zlib levels; -1 - default, based on configuration

    // !!! NOTE: when adding a new variable it is necessary to update all structure methods !!!

    CFTPServer() { Init(); }
    ~CFTPServer() { Release(); }

    void Init();

    // releases and zeroes the structure data
    void Release();

    // allocates a copy of the structure, returns NULL on error
    // NOTE: clears user-name, password, and save-passwd when anonymous connection is enabled
    CFTPServer* MakeCopy();

    // sets the structure, returns FALSE on error
    BOOL Set(const char* itemName,
             const char* address,
             const char* initialPath,
             int anonymousConnection,
             const char* userName,
             const BYTE* encryptedPassword,
             int encryptedPasswordSize,
             int savePassword,
             int proxyServerUID,
             const char* targetPanelPath,
             const char* serverType,
             int transferMode,
             int port,
             int usePassiveMode,
             int keepConnectionAlive,
             int useMaxConcurrentConnections,
             int maxConcurrentConnections,
             int useServerSpeedLimit,
             double serverSpeedLimit,
             int useListingsCache,
             const char* initFTPCommands,
             const char* listCommand,
             int keepAliveSendEvery,
             int keepAliveStopAfter,
             int keepAliveCommand,
             int encryptControlConnection,
             int encryptDataConnection,
             int compressData);

    // sets the structure based on source 'src', returns FALSE on error
    BOOL Set(const CFTPServer& src)
    {
        return Set(src.ItemName,
                   src.Address,
                   src.InitialPath,
                   src.AnonymousConnection,
                   src.UserName,
                   src.EncryptedPassword,
                   src.EncryptedPasswordSize,
                   src.SavePassword,
                   src.ProxyServerUID,
                   src.TargetPanelPath,
                   src.ServerType,
                   src.TransferMode,
                   src.Port,
                   src.UsePassiveMode,
                   src.KeepConnectionAlive,
                   src.UseMaxConcurrentConnections,
                   src.MaxConcurrentConnections,
                   src.UseServerSpeedLimit,
                   src.ServerSpeedLimit,
                   src.UseListingsCache,
                   src.InitFTPCommands,
                   src.ListCommand,
                   src.KeepAliveSendEvery,
                   src.KeepAliveStopAfter,
                   src.KeepAliveCommand,
                   src.EncryptControlConnection,
                   src.EncryptDataConnection,
                   src.CompressData);
    }

    // loads the structure, returns TRUE if the item is valid (should be added to the list)
    BOOL Load(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);
    // saves the structure
    void Save(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);

    // returns TRUE if the (plain) password can be obtained;
    // if a master password is used and not entered, asks the user for it (the window is shown via 'hParent);
    // if the user did not enter the correct master password or it could not decrypt the password, returns FALSE
    BOOL EnsurePasswordCanBeDecrypted(HWND hParent);
};

class CFTPProxyServerList;

class CFTPServerList : public TIndirectArray<CFTPServer>
{
public:
    CFTPServerList() : TIndirectArray<CFTPServer>(10, 10) {}

    // copies (allocates) all list items into list 'dstList' (first completely deletes it)
    // NOTE: clears user-name, password, and save-passwd when anonymous connection is enabled
    BOOL CopyMembersToList(CFTPServerList& dstList);

    // adds a bookmark to the FTP server list
    BOOL AddServer(const char* itemName,
                   const char* address = NULL,
                   const char* initialPath = NULL,
                   int anonymousConnection = TRUE,
                   const char* userName = NULL,
                   const BYTE* encryptedPassword = NULL,
                   int encryptedPasswordSize = 0,
                   int savePassword = FALSE,
                   int proxyServerUID = -2,
                   const char* targetPanelPath = NULL,
                   const char* serverType = NULL,
                   int transferMode = 0,
                   int port = IPPORT_FTP,
                   int usePassiveMode = 2,
                   int keepConnectionAlive = 2,
                   int useMaxConcurrentConnections = 2,
                   int maxConcurrentConnections = 1,
                   int useServerSpeedLimit = 2,
                   double serverSpeedLimit = 2,
                   int useListingsCache = 2,
                   const char* initFTPCommands = NULL,
                   const char* listCommand = NULL,
                   int keepAliveSendEvery = -1 /* -1 will be replaced with Config.KeepAliveSendEvery */,
                   int keepAliveStopAfter = -1 /* -1 will be replaced with Config.KeepAliveStopAfter */,
                   int keepAliveCommand = -1 /* -1 will be replaced with Config.KeepAliveCommand */,
                   int encryptControlConnection = 0,
                   int encryptDataConnection = 0,
                   int compressData = -1 /*default*/);

    void AddNamesToListbox(HWND list);

    // walks through the bookmark list and checks whether CFTPServer::ProxyServerUID is
    // still valid; if not, changes it to -2 (default proxy server)
    void CheckProxyServersUID(CFTPProxyServerList& ftpProxyServerList);

    // walks through the bookmark list and encrypts stored passwords with AES (encrypt==TRUE) or the scrambled method (encrypt==FALSE)
    // returns FALSE if some of the AES-encrypted passwords could not be decrypted, otherwise returns TRUE
    BOOL EncryptPasswords(HWND hParent, BOOL encrypt);

    // returns TRUE if the bookmark list contains an item whose password is not encrypted with AES (only scrambled)
    BOOL ContainsUnsecuredPassword();

    // loads the list
    void Load(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);
    // saves the list
    void Save(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);
};

//
// ****************************************************************************
// CFTPProxyServerList
//

enum CFTPProxyServerType
{
    fpstNotUsed = -1, // "direct connection" - symbolic value used for example in GetProxyScriptText()

    fpstSocks4 = 0,
    fpstSocks4A,
    fpstSocks5,
    fpstHTTP1_1,

    fpstFTP_SITE_host_colon_port,      // USER fw_user;PASS fw_pass;SITE host:port;USER user;PASS pass;ACCT acct
    fpstFTP_SITE_host_space_port,      // USER fw_user;PASS fw_pass;SITE host port;USER user;PASS pass;ACCT acct
    fpstFTP_SITE_user_host_colon_port, // USER fw_user;PASS fw_pass;SITE user@host:port;PASS pass;ACCT acct
    fpstFTP_SITE_user_host_space_port, // USER fw_user;PASS fw_pass;SITE user@host port;PASS pass;ACCT acct
    fpstFTP_OPEN_host_port,            // USER fw_user;PASS fw_pass;OPEN host:port;USER user;PASS pass;ACCT acct
    fpstFTP_transparent,               // (fw_host+fw_port are not used - connection goes to host+port) USER fw_user;PASS fw_pass;USER user;PASS pass;ACCT acct
    fpstFTP_USER_user_host_colon_port, // USER fw_user;PASS fw_pass;USER user@host:port;PASS pass;ACCT acct
    fpstFTP_USER_user_host_space_port, // USER fw_user;PASS fw_pass;USER user@host port;PASS pass;ACCT acct
    fpstFTP_USER_fireuser_host,        // USER fw_user@host:port;PASS fw_pass;USER user;PASS pass;ACCT acct
    fpstFTP_USER_user_host_fireuser,   // USER user@host:port fw_user;PASS pass;ACCT fw_pass;ACCT acct
    fpstFTP_USER_user_fireuser_host,   // USER user@fw_user@host:port;PASS pass@fw_pass;ACCT acct

    // NOTE: fpstOwnScript must be the last enum item
    fpstOwnScript, // the user wrote their own script for connecting to the FTP server
};

struct CFTPProxyServer;

struct CProxyScriptParams // helper structure for running proxy scripts
{
    char ProxyHost[HOST_MAX_SIZE];         // address/IP of the proxy server ("" = we must ask the user)
    int ProxyPort;                         // proxy server port (always defined)
    char ProxyUser[USER_MAX_SIZE];         // user name for logging in to the proxy server ("" = unknown, skip the whole line)
    char ProxyPassword[PASSWORD_MAX_SIZE]; // password for logging in to the proxy server ("" = we must ask the user)
    char Host[HOST_MAX_SIZE];              // address/IP of the FTP server (always defined)
    int Port;                              // FTP server port (always defined)
    char User[USER_MAX_SIZE];              // user name for logging in to the FTP server ("" = we must ask the user)
    char Password[PASSWORD_MAX_SIZE];      // password for logging in to the FTP server ("" = we must ask the user)
    char Account[ACCOUNT_MAX_SIZE];        // account for logging in to the FTP server ("" = we must ask the user)

    BOOL NeedProxyHost;     // TRUE = proxy server address/IP must be entered
    BOOL NeedProxyPassword; // TRUE = password for logging in to the proxy server must be entered
    BOOL NeedUser;          // TRUE = user name for logging in to the FTP server must be entered
    BOOL NeedPassword;      // TRUE = password for logging in to the FTP server must be entered
    BOOL NeedAccount;       // TRUE = account for logging in to the FTP server must be entered

    BOOL AllowEmptyPassword; // TRUE = the user intentionally entered an empty password (e.g. FileZilla server requires sending an empty password instead of reporting successful login after entering the user name, probably a safer approach)

    BOOL NeedUserInput() { return NeedProxyHost || NeedProxyPassword || NeedUser || NeedPassword || NeedAccount; }

    // 'host' cannot be NULL
    CProxyScriptParams(CFTPProxyServer* proxyServer, const char* host,
                       int port, const char* user, const char* password,
                       const char* account, BOOL allowEmptyPassword);
    CProxyScriptParams();
};

// validates or gradually executes a proxy script; during validation '*execPoint',
// 'scriptParams', 'hostBuf', 'port', 'sendCmdBuf', and 'logCmdBuf' are NULL and 'lastCmdReply'==-1;
// the function returns TRUE if the script is OK (FALSE on error, with the error text in 'errDescrBuf');
// 'script' is the proxy script text; '*execPoint' ('execPoint' must not be NULL) is
// the current execution position (the script is executed step by step); if it is NULL, we start
// validation/execution from the beginning of the script; 'lastCmdReply' is the result of the command from the previous
// line (-1 = previous line was skipped or this is the first line); 'scriptParams'
// contains the input values of individual variables; possible results of the
// ProcessProxyScript function:
// - script error: the function returns FALSE + the error position is returned in '*execPoint' + the error
//   description is in 'errDescrBuf'
// - missing variable value: the function returns TRUE and scriptParams->NeedUserInput()
//   returns TRUE (the value of '*execPoint' does not change)
// - successfully determined host:port to connect to (only at the beginning of the script): returns TRUE
//   and returns the connection target in 'hostBuf'+'port'; '*execPoint' points to the start
//   of the next script line
// - successfully determined which command to send to the server (not possible at the beginning of the script): returns
//   TRUE and 'sendCmdBuf' contains the command (including CRLF at the end), 'logCmdBuf' contains the
//   log text (the password is replaced with "(hidden)"); '*execPoint' points to the start
//   of the next script line
// - end of script (not possible at the beginning of the script): returns TRUE and 'sendCmdBuf' is an empty
//   string; '*execPoint' points to the end of the script;
// 'hostBuf' (if not NULL) is a buffer of size HOST_MAX_SIZE characters; 'sendCmdBuf'
// and 'logCmdBuf' (if not NULL) are buffers of size FTPCOMMAND_MAX_SIZE characters;
// 'errDescrBuf' is a buffer of size 300 characters; 'proxyHostNeeded' (if not NULL)
// returns TRUE if ProxyHost must be specified (we connect to it)
BOOL ProcessProxyScript(const char* script, const char** execPoint, int lastCmdReply,
                        CProxyScriptParams* scriptParams, char* hostBuf, unsigned short* port,
                        char* sendCmdBuf, char* logCmdBuf, char* errDescrBuf,
                        BOOL* proxyHostNeeded);

// returns the proxy script text for the given proxy server type; if the script is not defined,
// returns an empty string; if 'textForDialog' is TRUE it returns text for the Add/Edit Proxy Server
// dialog (Socks 4/4A/5 + HTTP 1.1 return "" for the dialog)
const char* GetProxyScriptText(CFTPProxyServerType type, BOOL textForDialog);

// returns the default port for a proxy server of the given type
unsigned short GetProxyDefaultPort(CFTPProxyServerType type);

// returns TRUE if the given proxy server type uses a password for the proxy server
BOOL HavePassword(CFTPProxyServerType type);

// returns TRUE if the given proxy server type uses the proxy server address and port
BOOL HaveHostAndPort(CFTPProxyServerType type);

// returns the proxy server type name (obtained before LoadStr, so the buffer is only temporary);
const char* GetProxyTypeName(CFTPProxyServerType type);

// returns TRUE for SOCKS4/4A/5 and HTTP 1.1 proxy servers
BOOL IsSOCKSOrHTTPProxy(CFTPProxyServerType type);

struct CFTPProxyForDataCon // data about the proxy server for the data connection
{
    CFTPProxyServerType ProxyType; // proxy server type
    DWORD ProxyHostIP;             // proxy server IP (more precisely: the IP the control connection connects to - used only for SOCKS4/4A/5 and HTTP 1.1)
    unsigned short ProxyPort;      // proxy server port
    char* ProxyUser;               // user name for logging in to the proxy server (NULL = empty)
    char* ProxyPassword;           // password for logging in to the proxy server (NULL = empty)
    char* Host;                    // FTP server address
    DWORD HostIP;                  // FTP server IP address
    unsigned short HostPort;       // FTP server port

    CFTPProxyForDataCon(CFTPProxyServerType proxyType, DWORD proxyHostIP,
                        unsigned short proxyPort, const char* proxyUser,
                        const char* proxyPassword, const char* host,
                        DWORD hostIP, unsigned short hostPort);
    ~CFTPProxyForDataCon();
};

struct CFTPProxyServer
{
    // access to object data through the CFTPProxyServerList::ProxyServerListCS critical section

    int ProxyUID;    // unique proxy server number (does not change, used to address the selected proxy server)
    char* ProxyName; // unique (case insensitive) proxy server name in combo boxes

    CFTPProxyServerType ProxyType; // proxy server type

    char* ProxyHost;                // proxy server address/IP
    int ProxyPort;                  // proxy server port
    char* ProxyUser;                // user name for logging in to the proxy server
    BYTE* ProxyEncryptedPassword;   // password for logging in to the proxy server
    int ProxyEncryptedPasswordSize; // number of bytes stored in EncryptedPassword
    char* ProxyPlainPassword;       // password for logging in to the proxy server; used internally only, filled from ProxyEncryptedPassword
    int SaveProxyPassword;          // TRUE = password should be stored on media (registry/config file)

    char* ProxyScript; // only for ProxyType==fpstOwnScript (otherwise NULL): script for connecting to the FTP server

    // !!! NOTE: when adding a new variable it is necessary to update all structure methods !!!

    CFTPProxyServer(int proxyUID) { Init(proxyUID); }
    ~CFTPProxyServer() { Release(); }

    void Init(int proxyUID);

    // releases and zeroes the structure data
    void Release();

    // allocates a copy of the structure, returns NULL on error
    CFTPProxyServer* MakeCopy();

    // allocates a CFTPProxyForDataCon structure, returns NULL on error
    CFTPProxyForDataCon* AllocProxyForDataCon(DWORD proxyHostIP, const char* host,
                                              DWORD hostIP, unsigned short hostPort);

    // sets ProxyHost
    BOOL SetProxyHost(const char* proxyHost);

    // sets ProxyPort
    void SetProxyPort(int proxyPort);

    // sets ProxyPlainPassword
    BOOL SetProxyPassword(const char* proxyPassword);

    // sets ProxyUser
    BOOL SetProxyUser(const char* proxyUser);

    // sets the structure, returns FALSE on error
    BOOL Set(int proxyUID,
             const char* proxyName,
             CFTPProxyServerType proxyType,
             const char* proxyHost,
             int proxyPort,
             const char* proxyUser,
             const BYTE* proxyEncryptedPassword,
             int proxyEncryptedPasswordSize,
             int saveProxyPassword,
             const char* proxyScript);

    // sets the structure based on source 'src', returns FALSE on error
    BOOL Set(const CFTPProxyServer& src)
    {
        return Set(src.ProxyUID,
                   src.ProxyName,
                   src.ProxyType,
                   src.ProxyHost,
                   src.ProxyPort,
                   src.ProxyUser,
                   src.ProxyEncryptedPassword,
                   src.ProxyEncryptedPasswordSize,
                   src.SaveProxyPassword,
                   src.ProxyScript);
    }

    // loads the structure, returns TRUE if the item is valid (should be added to the list)
    BOOL Load(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);
    // saves the structure
    void Save(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);
};

class CFTPProxyServerList : protected TIndirectArray<CFTPProxyServer>
{
protected:
    CRITICAL_SECTION ProxyServerListCS; // critical section for accessing all object data (writes are assumed only in the main thread, so reads from the main thread need not be synchronized; reads from other threads must be synchronized to avoid conflicts with writes, which occur only inside the critical section)

    int NextFreeProxyUID; // first free unique proxy server number (for CFTPProxyServer::ProxyUID)

public:
    CFTPProxyServerList();
    ~CFTPProxyServerList();

    TIndirectArray<CFTPProxyServer>::DestroyMembers;

    // returns TRUE if a proxy server with UID 'proxyServerUID' exists
    BOOL IsValidUID(int proxyServerUID);

    // checks whether the name 'proxyName' for proxy server 'proxyServer' is OK
    // (non-empty and unique among the other proxy servers)
    BOOL IsProxyNameOK(CFTPProxyServer* proxyServer, const char* proxyName);

    // copies (allocates) all elements of the list into the list 'dstList' (first deletes it completely)
    BOOL CopyMembersToList(CFTPProxyServerList& dstList);

    // fills the "Proxy Server" combo box; 'combo' is the combo box; 'focusProxyUID' is the UID of the server
    // that should be selected in the combo (-1 == "not used", -2 == "default"); if
    // 'addDefault' is TRUE, it adds the "default" item (used in the Connect to FTP Server dialog)
    void InitCombo(HWND combo, int focusProxyUID, BOOL addDefault);

    // retrieves the selection from the "Proxy Server" combo box; 'combo' is the combo box; 'focusedProxyUID'
    // returns the UID of the server selected in the combo (-1 == "not used", -2 == "default");
    // 'addDefault' is TRUE if the "default" item is added (used in the
    // Connect to FTP Server dialog)
    void GetProxyUIDFromCombo(HWND combo, int& focusedProxyUID, BOOL addDefault);

    // adds a new proxy server to the list (allocates it); also adds it to combo box 'combo';
    // 'parent' is the parent of the "Add Proxy Server" dialog
    void AddProxyServer(HWND parent, HWND combo);

    // lets the user edit the focused proxy server in combo box 'combo'; 'parent' is the parent of the
    // "Edit Proxy Server" dialog; 'addDefault' is TRUE if the "default"
    // item is added (used in the Connect to FTP Server dialog)
    void EditProxyServer(HWND parent, HWND combo, BOOL addDefault);

    // deletes the proxy server focused in combo box 'combo' (removes it from the proxy server list as well);
    // 'addDefault' is TRUE if the "default" item is added
    // (used in the Connect to FTP Server dialog); 'parent' is the parent of the confirmation
    // message box
    void DeleteProxyServer(HWND parent, HWND combo, BOOL addDefault);

    // moves the focused proxy server up in combo box 'combo' (and in the proxy server list);
    // 'addDefault' is TRUE if the "default" item is added (used in the Connect to FTP Server dialog)
    void MoveUpProxyServer(HWND combo, BOOL addDefault);

    // moves the focused proxy server down in combo box 'combo' (and in the proxy server list);
    // 'addDefault' is TRUE if the "default" item is added (used in the Connect to FTP Server dialog)
    void MoveDownProxyServer(HWND combo, BOOL addDefault);

    // copies the ProxyName of the proxy server with UID 'proxyServerUID'
    // into buffer 'buf' of size 'bufSize'; if 'proxyServerUID' is -1, copies "Not Used";
    // returns FALSE if 'proxyServerUID' is neither -1 nor a valid proxy server UID
    BOOL GetProxyName(char* buf, int bufSize, int proxyServerUID);

    // loads the list
    void Load(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);
    // saves the list
    void Save(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);

    // calls proxyServer->Set() inside the critical section
    BOOL SetProxyServer(CFTPProxyServer* proxyServer,
                        int proxyUID,
                        const char* proxyName,
                        CFTPProxyServerType proxyType,
                        const char* proxyHost,
                        int proxyPort,
                        const char* proxyUser,
                        const BYTE* proxyEncryptedPassword,
                        int proxyEncryptedPasswordSize,
                        int saveProxyPassword,
                        const char* proxyScript);

    // returns a copy of the proxy server with UID 'proxyServerUID'; if not found or
    // memory for its copy is insufficient, returns NULL; in 'lowMem' (if not NULL)
    // returns TRUE if the error was caused by lack of memory
    CFTPProxyServer* MakeCopyOfProxyServer(int proxyServerUID, BOOL* lowMem);

    // returns the proxy server type with UID 'proxyServerUID'; for an unknown UID returns fpstNotUsed
    CFTPProxyServerType GetProxyType(int proxyServerUID);

    // walks through the server list and encrypts stored passwords with AES (encrypt==TRUE) or the scrambled method (encrypt==FALSE)
    // returns FALSE if some of the AES-encrypted passwords could not be decrypted, otherwise returns TRUE
    BOOL EncryptPasswords(HWND hParent, BOOL encrypt);

    // returns TRUE if the server list contains an item whose password is not encrypted with AES (only scrambled)
    BOOL ContainsUnsecuredPassword();

    // returns TRUE if the (plain) password for the proxy server with UID 'proxyServerUID' can be obtained;
    // if a master password is used and not entered, asks the user for it (window is shown via 'hParent)
    // if the user did not enter the correct master password or it could not decrypt the password, returns FALSE
    BOOL EnsurePasswordCanBeDecrypted(HWND hParent, int proxyServerUID);
};

//
// ****************************************************************************
// CConfiguration
//

enum CTransferMode
{
    trmBinary,
    trmASCII,
    trmAutodetect
};

class CConfiguration
{
public:
    DWORD LastCfgPage; // index of the last page focused in the configuration dialog

    int ShowWelcomeMessage;         // show the server's welcome message
    int PriorityToPanelConnections; // prioritize connections for panels (listing, download for view, etc.)
    int EnableTotalSpeedLimit;      // is the overall speed limit for the FTP client enabled?
    double TotalSpeedLimit;         // overall speed limit for the FTP client

    int PassiveMode;                 // use passive mode by default?
    int KeepAlive;                   // keep the connection alive by default?
    int UseMaxConcurrentConnections; // default: 1 = use the MaxConcurrentConnections limit; 0 = no limit
    int MaxConcurrentConnections;    // default max number of concurrent connections to the server (control+data counts as one connection)
    int UseServerSpeedLimit;         // default: 1 = use the ServerSpeedLimit limit; 0 = no limit
    double ServerSpeedLimit;         // default overall speed limit for the server
    int UseListingsCache;            // cache for viewed files and listings: use cache by default?
    int TransferMode;                // file transfer mode (binary/ascii/auto) (values of type CTransferMode)

    CSalamanderMaskGroup* ASCIIFileMasks; // for automatic transfer mode - masks for the "ascii" mode (others will be "binary")

    int KeepAliveSendEvery; // how often to send keep-alive commands
    int KeepAliveStopAfter; // when to stop sending keep-alive commands
    int KeepAliveCommand;   // command for keep-alive (0-NOOP, 1-PWD, 2-NLST, 3-LIST)

    int CompressData; // 0 - no; 1-9 - zlib levels;

    CFTPServerList FTPServerList; // list of bookmarks to FTP servers
    int LastBookmark;             // last selected FTP server bookmark from the "Connect to FTP Server" dialog (0 = "quick connect" selected)

    CFTPProxyServerList FTPProxyServerList; // list of user-defined proxy servers
    int DefaultProxySrvUID;                 // UID of the default proxy server (-1 == "not used")

    int AlwaysNotCloseCon; // TRUE = do not ask before changing path from the FS - user always wants "detach" (not to close)
    int AlwaysDisconnect;  // TRUE = do not ask before disconnecting - user always wants "close connection"

    int EnableLogging;           // TRUE = logging of communication with the server is enabled
    int UseLogMaxSize;           // TRUE = use LogMaxSize
    int LogMaxSize;              // maximum size of one server's log [in KB]
    int UseMaxClosedConLogs;     // TRUE = use MaxClosedConLogs
    int MaxClosedConLogs;        // maximum number of logs of closed connections (older ones are discarded)
    int AlwaysShowLogForActPan;  // TRUE = activate the log when the FTP connection becomes active in the panel
    int DisableLoggingOfWorkers; // TRUE = disable logging of worker communication with the server

    WINDOWPLACEMENT LogsDlgPlacement;            // position of the Logs dialog
    WINDOWPLACEMENT OperDlgPlacement;            // position of the Operations dialog (user's last setting)
    double OperDlgSplitPos;                      // position of the splitter between list views in the Operations dialog
    int CloseOperationDlgIfSuccessfullyFinished; // TRUE = automatically close the operations dialog when an operation finishes without errors/questions in the untouched dialog
    int CloseOperationDlgWhenOperFinishes;       // TRUE = close the operations dialog after the operation completes (if no Solve Error dialog is open)
    int OpenSolveErrIfIdle;                      // TRUE = automatically open the Solve Error dialog when it is idle

    char* CommandHistory[COMMAND_HISTORY_SIZE]; // history of FTP commands (from the "Send FTP Command" command)
    int SendSecretCommand;                      // last state of the "Secret command" checkbox in the "Send FTP Command" dialog

    char* HostAddressHistory[HOSTADDRESS_HISTORY_SIZE]; // history of server addresses in the Connect to FTP Server dialog
    char* InitPathHistory[INITIALPATH_HISTORY_SIZE];    // history of initial paths on the server in the Connect to FTP Server dialog

    int AlwaysReconnect;     // TRUE = do not ask about reconnecting (after losing the connection, the next request to the server will reconnect)
    int WarnWhenConLost;     // TRUE = warn the user that the connection to the server was just lost
    int HintListHiddenFiles; // TRUE = show the hint "how to list hidden files (unix)"
    int AlwaysOverwrite;     // TRUE = do not ask about overwrite (applies to Quick Rename)

    int ConvertHexEscSeq; // TRUE = convert hex escape sequences ("%20" -> " ") in user-entered paths

    CQuadWord CacheMaxSize; // max cache size (currently stored only in memory); NOTE: currently stored as DWORD in the registry!!!

    BOOL DownloadAddToQueue; // TRUE = for "copy/move from FTP" only add to queue (do not process immediately in the active connection)
    BOOL DeleteAddToQueue;   // TRUE = for "delete from FTP" only add to queue (do not process immediately in the active connection)
    BOOL ChAttrAddToQueue;   // TRUE = for "change-attributes on FTP" only add to queue (do not process immediately in the active connection)

    // Copy+Move from FTP: user-preferred ways of solving the following problems
    int OperationsCannotCreateFile;      // see constants CANNOTCREATENAME_XXX
    int OperationsCannotCreateDir;       // see constants CANNOTCREATENAME_XXX
    int OperationsFileAlreadyExists;     // see constants FILEALREADYEXISTS_XXX
    int OperationsDirAlreadyExists;      // see constants DIRALREADYEXISTS_XXX
    int OperationsRetryOnCreatedFile;    // see constants RETRYONCREATFILE_XXX
    int OperationsRetryOnResumedFile;    // see constants RETRYONRESUMFILE_XXX
    int OperationsAsciiTrModeButBinFile; // see constants ASCIITRFORBINFILE_XXX

    // Change Attributes on FTP: user-preferred ways of solving the following problems
    int OperationsUnknownAttrs; // see constants UNKNOWNATTRS_XXX

    // Delete on FTP: user-preferred ways of solving the following situations
    int OperationsNonemptyDirDel; // see constants NONEMPTYDIRDEL_XXX
    int OperationsHiddenFileDel;  // see constants HIDDENFILEDEL_XXX
    int OperationsHiddenDirDel;   // see constants HIDDENDIRDEL_XXX

    // Copy+Move to FTP: user-preferred ways of solving the following problems
    int UploadCannotCreateFile;      // see constants CANNOTCREATENAME_XXX
    int UploadCannotCreateDir;       // see constants CANNOTCREATENAME_XXX
    int UploadFileAlreadyExists;     // see constants FILEALREADYEXISTS_XXX
    int UploadDirAlreadyExists;      // see constants DIRALREADYEXISTS_XXX
    int UploadRetryOnCreatedFile;    // see constants RETRYONCREATFILE_XXX
    int UploadRetryOnResumedFile;    // see constants RETRYONRESUMFILE_XXX
    int UploadAsciiTrModeButBinFile; // see constants ASCIITRFORBINFILE_XXX

    // *****************************************************************************
    // the following data are not saved (kept only in memory, then discarded):
    // *****************************************************************************

    BOOL UseConnectionDataFromConfig; // TRUE only after pressing the "Connect" button in the Connect dialog
    BOOL ChangingPathInInactivePanel; // TRUE only when changing the path in the inactive panel (clicking the FTP button in the inactive drive bar)
    CFTPServer QuickConnectServer;    // data for Quick Connect (passing data from the Connect dialog)

    BOOL DisconnectCommandUsed; // TRUE only after using the "Disconnect" command (not for disconnecting a detached FS)

    int TestParserDlgWidth;  // width of the "Test of Parser" dialog (-1 = default width; -2 = maximized)
    int TestParserDlgHeight; // height of the "Test of Parser" dialog (-1 = default height)

protected:                             // data used from multiple threads, access is synchronized:
    CServerTypeList ServerTypeList;    // list of server types
    CRITICAL_SECTION ServerTypeListCS; // critical section for accessing ServerTypeList

    // critical section for accessing connection parameters; the following variables are
    // protected by this critical section
    CRITICAL_SECTION ConParamsCS;
    char AnonymousPasswd[PASSWORD_MAX_SIZE]; // password for anonymous connection (user's e-mail)
    int ServerRepliesTimeout;                // how long to wait for a server response
    int DelayBetweenConRetries;              // delay before repeating a connect attempt
    int ConnectRetries;                      // how many times to attempt reconnect (if login fails for reasons other than "invalid password")
    int ResumeMinFileSize;                   // minimum file size for "resume" (continuing a download) to make sense
    int ResumeOverlap;                       // how many bytes at the end of the file to test when resuming a download
    int NoDataTransferTimeout;               // how long to wait for data while the data connection is idle (no-data-transfer)
                                             // end of variables protected by the ConParamsCS critical section

public:
    CConfiguration();
    ~CConfiguration();

    BOOL InitWithSalamanderGeneral();        // initialization after obtaining the SalamanderGeneral pointer
    void ReleaseDataFromSalamanderGeneral(); // cleanup before releasing the SalamanderGeneral pointer

    // locks access to ServerTypeList and returns a pointer to it; unlock by calling
    // UnlockServerTypeList()
    CServerTypeList* LockServerTypeList()
    {
        HANDLES(EnterCriticalSection(&ServerTypeListCS));
        return &ServerTypeList;
    }
    // unlocks access to ServerTypeList (must match a LockServerTypeList() call)
    void UnlockServerTypeList() { HANDLES(LeaveCriticalSection(&ServerTypeListCS)); }

    // helper methods for accessing variables protected by the ConParamsCS section
    void GetAnonymousPasswd(char* buf, int bufSize);
    void SetAnonymousPasswd(const char* passwd);
    int GetServerRepliesTimeout();
    void SetServerRepliesTimeout(int value);
    int GetDelayBetweenConRetries(); // returns at least value 1 (this method ensures value validation)
    void SetDelayBetweenConRetries(int value);
    int GetConnectRetries();
    void SetConnectRetries(int value);
    int GetResumeOverlap();
    void SetResumeOverlap(int value);
    int GetResumeMinFileSize();
    void SetResumeMinFileSize(int value);
    int GetNoDataTransferTimeout();
    void SetNoDataTransferTimeout(int value);

    friend class CConfigPageAdvanced;
};

extern CConfiguration Config; // global configuration of the FTP client

//
// ****************************************************************************
// CPluginInterface
//

class CPluginInterfaceForFS : public CPluginInterfaceForFSAbstract
{
protected:
    int ActiveFSCount; // number of active FS interfaces (only for monitoring deallocation)

public:
    CPluginInterfaceForFS() { ActiveFSCount = 0; }
    int GetActiveFSCount() { return ActiveFSCount; }

    virtual CPluginFSInterfaceAbstract* WINAPI OpenFS(const char* fsName, int fsNameIndex);
    virtual void WINAPI CloseFS(CPluginFSInterfaceAbstract* fs);

    virtual void WINAPI ExecuteOnFS(int panel, CPluginFSInterfaceAbstract* pluginFS,
                                    const char* pluginFSName, int pluginFSNameIndex,
                                    CFileData& file, int isDir);
    virtual BOOL WINAPI DisconnectFS(HWND parent, BOOL isInPanel, int panel,
                                     CPluginFSInterfaceAbstract* pluginFS,
                                     const char* pluginFSName, int pluginFSNameIndex);

    virtual void WINAPI ConvertPathToInternal(const char* fsName, int fsNameIndex,
                                              char* fsUserPart);
    virtual void WINAPI ConvertPathToExternal(const char* fsName, int fsNameIndex,
                                              char* fsUserPart);

    virtual void WINAPI EnsureShareExistsOnServer(int panel, const char* server, const char* share) {}

    virtual void WINAPI ExecuteChangeDriveMenuItem(int panel);
    virtual BOOL WINAPI ChangeDriveMenuItemContextMenu(HWND parent, int panel, int x, int y,
                                                       CPluginFSInterfaceAbstract* pluginFS,
                                                       const char* pluginFSName, int pluginFSNameIndex,
                                                       BOOL isDetachedFS, BOOL& refreshMenu,
                                                       BOOL& closeMenu, int& postCmd, void*& postCmdParam);
    virtual void WINAPI ExecuteChangeDrivePostCommand(int panel, int postCmd, void* postCmdParam);
};

class CPluginInterfaceForMenuExt : public CPluginInterfaceForMenuExtAbstract
{
public:
    virtual DWORD WINAPI GetMenuItemState(int id, DWORD eventMask);
    virtual BOOL WINAPI ExecuteMenuItem(CSalamanderForOperationsAbstract* salamander, HWND parent,
                                        int id, DWORD eventMask);
    virtual BOOL WINAPI HelpForMenuItem(HWND parent, int id);
    virtual void WINAPI BuildMenu(HWND parent, CSalamanderBuildMenuAbstract* salamander) {}
};

class CPluginInterface : public CPluginInterfaceAbstract
{
public:
    virtual void WINAPI About(HWND parent);

    virtual BOOL WINAPI Release(HWND parent, BOOL force);

    virtual void WINAPI LoadConfiguration(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);
    virtual void WINAPI SaveConfiguration(HWND parent, HKEY regKey, CSalamanderRegistryAbstract* registry);
    virtual void WINAPI Configuration(HWND parent);

    virtual void WINAPI Connect(HWND parent, CSalamanderConnectAbstract* salamander);

    virtual void WINAPI ReleasePluginDataInterface(CPluginDataInterfaceAbstract* pluginData);

    virtual CPluginInterfaceForArchiverAbstract* WINAPI GetInterfaceForArchiver() { return NULL; }
    virtual CPluginInterfaceForViewerAbstract* WINAPI GetInterfaceForViewer() { return NULL; }
    virtual CPluginInterfaceForMenuExtAbstract* WINAPI GetInterfaceForMenuExt();
    virtual CPluginInterfaceForFSAbstract* WINAPI GetInterfaceForFS();
    virtual CPluginInterfaceForThumbLoaderAbstract* WINAPI GetInterfaceForThumbLoader() { return NULL; }

    virtual void WINAPI Event(int event, DWORD param);
    virtual void WINAPI ClearHistory(HWND parent);
    virtual void WINAPI AcceptChangeOnPathNotification(const char* path, BOOL includingSubdirs);

    virtual void WINAPI PasswordManagerEvent(HWND parent, int event);
};

//
// ****************************************************************************
// FILE-SYSTEM
//

//****************************************************************************
//
// CTopIndexMem
//
// top-index memory of the list box in the panel - used by CPluginFSInterface for correct
// behavior of ExecuteOnFS (preserving the top index after entering and leaving a subdirectory)

#define TOP_INDEX_MEM_SIZE 50 // number of remembered top indices (levels), at least 1

class CTopIndexMem
{
protected:
    // path for the last remembered top index (note it is case-sensitive)
    char Path[FTP_MAX_PATH];
    int TopIndexes[TOP_INDEX_MEM_SIZE]; // remembered top indices
    int TopIndexesCount;                // number of remembered top indices

public:
    CTopIndexMem() { Clear(); }

    // clears the memory
    void Clear()
    {
        Path[0] = 0;
        TopIndexesCount = 0;
    }

    // stores the top index for the given path
    void Push(CFTPServerPathType type, const char* path, int topIndex);

    // searches for the top index for the given path, FALSE -> not found
    BOOL FindAndPop(CFTPServerPathType type, const char* path, int& topIndex);
};

//
// ****************************************************************************
// CSimpleListPluginDataInterface
//

class CSimpleListPluginDataInterface : public CPluginDataInterfaceAbstract
{
public:
    static int ListingColumnWidth;      // LO/HI-WORD: left/right panel: width of the Raw Listing column
    static int ListingColumnFixedWidth; // LO/HI-WORD: left/right panel: does the Raw Listing column have a fixed width?

public:
    virtual BOOL WINAPI CallReleaseForFiles() { return TRUE; }
    virtual BOOL WINAPI CallReleaseForDirs() { return TRUE; }
    virtual void WINAPI ReleasePluginData(CFileData& file, BOOL isDir);

    virtual void WINAPI GetFileDataForUpDir(const char* archivePath, CFileData& upDir) {}          // FS does not use
    virtual BOOL WINAPI GetFileDataForNewDir(const char* dirName, CFileData& dir) { return TRUE; } // FS does not use

    virtual HIMAGELIST WINAPI GetSimplePluginIcons(int iconSize) { return NULL; }                               // we do not have custom icons
    virtual BOOL WINAPI HasSimplePluginIcon(CFileData& file, BOOL isDir) { return TRUE; }                       // we do not have custom icons
    virtual HICON WINAPI GetPluginIcon(const CFileData* file, int iconSize, BOOL& destroyIcon) { return NULL; } // we do not have custom icons
    virtual int WINAPI CompareFilesFromFS(const CFileData* file1, const CFileData* file2) { return 0; }         // we do not have custom icons

    virtual void WINAPI SetupView(BOOL leftPanel, CSalamanderViewAbstract* view, const char* archivePath,
                                  const CFileData* upperDir);
    virtual void WINAPI ColumnFixedWidthShouldChange(BOOL leftPanel, const CColumn* column, int newFixedWidth);
    virtual void WINAPI ColumnWidthWasChanged(BOOL leftPanel, const CColumn* column, int newWidth);

    virtual BOOL WINAPI GetInfoLineContent(int panel, const CFileData* file, BOOL isDir, int selectedFiles,
                                           int selectedDirs, BOOL displaySize, const CQuadWord& selectedSize,
                                           char* buffer, DWORD* hotTexts, int& hotTextsCount);

    virtual BOOL WINAPI CanBeCopiedToClipboard() { return TRUE; }

    virtual BOOL WINAPI GetByteSize(const CFileData* file, BOOL isDir, CQuadWord* size) { return FALSE; }
    virtual BOOL WINAPI GetLastWriteDate(const CFileData* file, BOOL isDir, SYSTEMTIME* date) { return FALSE; }
    virtual BOOL WINAPI GetLastWriteTime(const CFileData* file, BOOL isDir, SYSTEMTIME* time) { return FALSE; }
};

//
// ****************************************************************************
// CFTPListingPluginDataInterface
//

#pragma pack(push, enter_include_ftp_h_dt) // to keep the structures as small as possible (both fit into 4 bytes)
#pragma pack(1)

struct CFTPDate // structure for storing a value for a column of type stctGeneralDate
{
    BYTE Day;
    BYTE Month;
    WORD Year;
};

struct CFTPTime // structure for storing a value for a column of type stctGeneralTime
{
    unsigned Hour : 8;         // BYTE
    unsigned Minute : 8;       // BYTE
    unsigned Second : 6;       // enough for seconds (values < 64)
    unsigned Millisecond : 10; // enough for milliseconds (values < 1024)
};

#pragma pack(pop, enter_include_ftp_h_dt)

class CFTPListingPluginDataInterface : public CPluginDataInterfaceAbstract
{
protected:
    TIndirectArray<CSrvTypeColumn>* Columns; // column definitions for the panel (cannot be NULL)
    BOOL DeleteColumns;                      // TRUE = the destructor should delete Columns
    DWORD ItemDataSize;                      // size of the allocated structure (stored in CFileData::PluginData) with data for the columns
    DWORD* DataOffsets;                      // data offsets for individual columns in CFileData::PluginData (-1 when data are stored directly in CFileData)
    DWORD ValidDataMask;                     // data validity mask in the CFileData structures (combination of VALID_DATA_XXX)

    // only one size is used, priority order: CFileData::Size, Size in Bytes, Size in Blocks
    DWORD BytesColumnOffset;  // if not -1, offset of a stctGeneralNumber value representing the number of bytes of the file (the listing contains the "Size" column)
    DWORD BlocksColumnOffset; // if not -1, offset of a stctGeneralNumber value representing the number of blocks of the file (the listing contains the "Blocks" column)

    // date+time of the last write to the file, columns labelled Date, Time; values stored
    // in CFileData::LastWrite or stctGeneralDate/stctGeneralTime
    DWORD DateColumnOffset; // if not -1, and LastWrite is -2, offset of a stctGeneralDate value representing the date of the last write to the file
    DWORD TimeColumnOffset; // if not -1, and LastWrite is -2, offset of a stctGeneralTime value representing the time of the last write to the file

    BOOL IsVMS; // TRUE = the listing originates from VMS (GetBasicName() is used)

public:
    CFTPListingPluginDataInterface(TIndirectArray<CSrvTypeColumn>* columns, BOOL deleteColumns,
                                   DWORD validDataMask, BOOL isVMS);
    ~CFTPListingPluginDataInterface();

    // returns TRUE only if the object is OK and can be used - checked after the object is constructed
    BOOL IsGood() { return DataOffsets != NULL; }

    // allocates file.PluginData; returns FALSE on low memory
    BOOL AllocPluginData(CFileData& file);

    // prepares data in file.PluginData for further use (deallocates and clears strings)
    void ClearPluginData(CFileData& file);

    // stores the allocated string 'str' into the structure 'file' into column 'column';
    // 'str' is deallocated when ReleasePluginData() is called for 'file'; when
    // overwriting a string the overwritten string is deallocated
    void StoreStringToColumn(CFileData& file, int column, char* str);

    // stores day 'day' into the structure 'file' into column 'column' into a CFTPDate structure
    void StoreDayToColumn(CFileData& file, int column, BYTE day);

    // stores month 'month' into the structure 'file' into column 'column' into a CFTPDate structure
    void StoreMonthToColumn(CFileData& file, int column, BYTE month);

    // stores year 'year' into the structure 'file' into column 'column' into a CFTPDate structure
    void StoreYearToColumn(CFileData& file, int column, WORD year);

    // stores date 'day'+'month'+'year' into the structure 'file' into column 'column' into a CFTPDate structure
    void StoreDateToColumn(CFileData& file, int column, BYTE day, BYTE month, WORD year);

    // stores time 'hour'+'minute'+'second'+'millisecond' into the structure 'file' into column 'column'
    // into a CFTPTime structure
    void StoreTimeToColumn(CFileData& file, int column, BYTE hour, BYTE minute,
                           BYTE second, WORD millisecond);

    // stores number 'number' into the structure 'file' into column 'column'
    void StoreNumberToColumn(CFileData& file, int column, __int64 number);

    // returns a string from the structure 'file' from column 'column'
    char* GetStringFromColumn(const CFileData& file, int column);

    // returns (in the relevant part of the structure 'stVal') the date from the structure 'file' from column 'column'
    void GetDateFromColumn(const CFileData& file, int column, SYSTEMTIME* stVal);

    // returns in 'date' the date from the structure 'file' from column 'column'
    void GetDateFromColumn(const CFileData& file, int column, CFTPDate* date);

    // returns (in the relevant part of the structure 'stVal') the time from the structure 'file' from column 'column'
    void GetTimeFromColumn(const CFileData& file, int column, SYSTEMTIME* stVal);

    // returns in 'time' the time from the structure 'file' from column 'column'
    void GetTimeFromColumn(const CFileData& file, int column, CFTPTime* time);

    // returns a number from the structure 'file' from column 'column';
    // NOTE: if it returns an empty value in the column, it returns INT64_EMPTYNUMBER
    __int64 GetNumberFromColumn(const CFileData& file, int column);

    // finds the "Rights" column with textual content; if it does not exist, returns -1
    int FindRightsColumn();

    // if the size of the file 'file' is known, returns TRUE and the size in 'size' and
    // in 'inBytes' returns TRUE/FALSE depending on whether the size is in bytes/blocks;
    // if the file size is not known, returns FALSE and does not modify 'size' or 'inBytes'
    BOOL GetSize(const CFileData& file, CQuadWord& size, BOOL& inBytes);

    // returns the base name - currently used only when trimming version numbers from
    // file names on VMS (for example, versions do not fit well when matching masks);
    // 'file' is the file being processed; in 'name'+'ext' (must not be NULL) it returns
    // a pointer to the name and extension (just a pointer into the name); 'buffer' is
    // an auxiliary buffer (size at least MAX_PATH) into which the adjusted name is stored
    void GetBasicName(const CFileData& file, char** name, char** ext, char* buffer);

    // returns the date and time of the last write to the file; in 'dateAndTimeValid' returns
    // FALSE if this date+time is not known; also returns "empty values":
    // for the date it sets date->Day == 0, for the time it sets time->Hour == 24
    void GetLastWriteDateAndTime(const CFileData& file, BOOL* dateAndTimeValid,
                                 CFTPDate* date, CFTPTime* time);

    // returns a combination of the constants VALID_DATA_PL_SIZE/VALID_DATA_PL_DATE/VALID_DATA_PL_TIME
    // according to BytesColumnOffset/DateColumnOffset/TimeColumnOffset
    DWORD GetPLValidDataMask();

    // ************************************************************************************
    // definition of methods of the CPluginDataInterfaceAbstract interface
    // ************************************************************************************

    virtual BOOL WINAPI CallReleaseForFiles() { return TRUE; }
    virtual BOOL WINAPI CallReleaseForDirs() { return TRUE; }
    virtual void WINAPI ReleasePluginData(CFileData& file, BOOL isDir);

    virtual void WINAPI GetFileDataForUpDir(const char* archivePath, CFileData& upDir) {}          // FS does not use
    virtual BOOL WINAPI GetFileDataForNewDir(const char* dirName, CFileData& dir) { return TRUE; } // FS does not use

    virtual HIMAGELIST WINAPI GetSimplePluginIcons(int iconSize) { return NULL; }                               // we do not have custom icons
    virtual BOOL WINAPI HasSimplePluginIcon(CFileData& file, BOOL isDir) { return TRUE; }                       // we do not have custom icons
    virtual HICON WINAPI GetPluginIcon(const CFileData* file, int iconSize, BOOL& destroyIcon) { return NULL; } // we do not have custom icons
    virtual int WINAPI CompareFilesFromFS(const CFileData* file1, const CFileData* file2) { return 0; }         // we do not have custom icons

    virtual void WINAPI SetupView(BOOL leftPanel, CSalamanderViewAbstract* view, const char* archivePath,
                                  const CFileData* upperDir);
    virtual void WINAPI ColumnFixedWidthShouldChange(BOOL leftPanel, const CColumn* column, int newFixedWidth);
    virtual void WINAPI ColumnWidthWasChanged(BOOL leftPanel, const CColumn* column, int newWidth);

    virtual BOOL WINAPI GetInfoLineContent(int panel, const CFileData* file, BOOL isDir, int selectedFiles,
                                           int selectedDirs, BOOL displaySize, const CQuadWord& selectedSize,
                                           char* buffer, DWORD* hotTexts, int& hotTextsCount);

    virtual BOOL WINAPI CanBeCopiedToClipboard() { return TRUE; }

    virtual BOOL WINAPI GetByteSize(const CFileData* file, BOOL isDir, CQuadWord* size);
    virtual BOOL WINAPI GetLastWriteDate(const CFileData* file, BOOL isDir, SYSTEMTIME* date);
    virtual BOOL WINAPI GetLastWriteTime(const CFileData* file, BOOL isDir, SYSTEMTIME* time);
};

//
// ****************************************************************************
// CPluginFSInterface
//
// set of plugin methods Salamander needs to work with the file system

class CControlConnectionSocket;
class CFTPOperation;
class CFTPWorker;

// error codes for communication between ListCurrentPath and ChangePath:
enum CFTPErrorState
{
    fesOK,               // no error
    fesFatal,            // fatal error while listing (ChangePath should only return FALSE)
    fesInaccessiblePath, // the path cannot be listed, the path must be shortened
};

class CPluginFSInterface : public CPluginFSInterfaceAbstract
{
protected:
    char Host[HOST_MAX_SIZE]; // host (FTP server)
    int Port;                 // port on which the FTP server runs
    char User[USER_MAX_SIZE]; // user
    char Path[FTP_MAX_PATH];  // current path on FTP (remote path; note that it is case-sensitive)

    CFTPErrorState ErrorState;
    BOOL IsDetached;          // is this FS detached? (FALSE = it is in a panel)
    CTopIndexMem TopIndexMem; // top-index memory for ExecuteOnFS()

    CControlConnectionSocket* ControlConnection; // "control connection" socket to the FTP server (NULL == never connected)
    char RescuePath[FTP_MAX_PATH];               // rescue path on FTP - try when ChangePath() can no longer shorten the path
    char HomeDir[FTP_MAX_PATH];                  // default path on FTP - set after logging into the server
    BOOL OverwritePathListing;                   // if TRUE, PathListing should be overwritten with a new listing (once/if we obtain it) - handles the situation when ChangePath is called and ListCurrentPath is no longer invoked because the path did not change
    char* PathListing;                           // if not NULL, contains at least part (can also be "") of the listing of the current path
    int PathListingLen;                          // length of the string in PathListing
    CFTPDate PathListingDate;                    // date when the listing was obtained (needed for "year_or_time")
    BOOL PathListingIsIncomplete;                // TRUE = PathListing contains only part (can also be "") of the listing; FALSE = the listing is complete
    BOOL PathListingIsBroken;                    // TRUE = PathListing contains a corrupted listing (the server returned an error while retrieving the listing)
    BOOL PathListingMayBeOutdated;               // TRUE = PathListing contains a listing that may no longer be up to date (used by Upload: when F5/F6 is pressed in the panel, it checks whether there is an operation running that could damage the listing; it does not handle possible damage during a drag&drop operation because the start of drag&drop is unknown to the plugin)
    DWORD PathListingStartTime;                  // IncListingCounter() from the moment the "LIST" command is sent to the server (when retrieving the PathListing listing)

    CFTPServerPathType DirLineHotPathType; // helper variable: path type for which hot-texts are identified in Directory Line
    int DirLineHotPathUserLength;          // helper variable: length of the current username if it contains "disallowed" characters

    DWORD ChangePathOnlyGetCurPathTime; // helper variable for optimizing ChangePath() called right after retrieving the working path

    // helper variable for passing the total number of connection attempts between individual calls to
    // ChangePath(), ListCurrentPath(), GetFullFSPath(), SendUserFTPCommand(), and ViewFile()
    int TotalConnectAttemptNum;

    BOOL AutodetectSrvType;                   // TRUE = autodetection should be used to determine the server type; FALSE = LastServerType contains the type selected by the user (if it ceases to exist, AutodetectSrvType switches back to TRUE)
    char LastServerType[SERVERTYPE_MAX_SIZE]; // name of the server type (without an optional leading '*') that was last used to parse the listing (ensures the same columns in the panel even for empty directories)

    BOOL InformAboutUnknownSrvType;   // TRUE until the user is informed that we cannot find a listing parser (unsupported server type)
    BOOL NextRefreshCanUseOldListing; // TRUE only if only the configuration changed (parsers, columns) and therefore it is not necessary to read the listing from the server again
    BOOL NextRefreshWontClearCache;   // TRUE only if the refresh happened based on a "change on path" notification and it is therefore not necessary to clear the current path from the cache (done elsewhere)

    int TransferMode; // file transfer mode (binary/ascii/auto) (values of type CTransferMode)

    BOOL CalledFromDisconnectDialog; // TRUE = the user wants to disconnect this FS from the Disconnect dialog (F12 key)

    BOOL RefreshPanelOnActivation; // TRUE = refresh is performed once the main Salamander window becomes active

public:
    CPluginFSInterface();
    ~CPluginFSInterface();

    // creates the user-part of an FTP path - format "//user@host:port/path"; 'buffer' is
    // the buffer for the result with size 'bufferSize' bytes; 'path' is the FTP path, if
    // 'path' is NULL the current FTP path is used; if 'ignorePath' is TRUE the user-part
    // path is created without the FTP path; returns TRUE if the buffer 'buffer'
    // is large enough for the result (otherwise the result is truncated and FALSE is returned)
    BOOL MakeUserPart(char* buffer, int bufferSize, char* path = NULL, BOOL ignorePath = FALSE);

    // saves the connection data (host+port+user+passwd+...) into Config.FTPServerList
    // the user chooses the bookmark name in the dialog
    void AddBookmark(HWND parent);

    // sends an FTP command to the server (the user enters the command in the dialog);
    // 'parent' is the "foreground" window of the thread (after pressing ESC it is used to
    // determine whether ESC was pressed in this window and not in another application; in the main thread it is
    // SalamanderGeneral->GetMsgBoxParent() or a dialog opened by the plugin); 'parent' is
    // also the parent of any error message boxes
    void SendUserFTPCommand(HWND parent);

    // shows the raw listing (text from the server) for the current path in the panel; 'parent' is the parent
    // of the dialog with the listing
    void ShowRawListing(HWND parent);

    // tests whether we are using the "control connection" 'ctrlCon'
    BOOL Contains(const CControlConnectionSocket* ctrlCon) const { return ctrlCon == ControlConnection; }

    // used only to detect the FS placement (left/right panel or detached FS);
    // the returned pointer is therefore not dereferenced (only the value is compared)
    CControlConnectionSocket* GetControlConnection() { return ControlConnection; }

    // returns the UID of the log from the "control connection" or -1 if none exists
    int GetLogUID();

    // if the user has not yet been informed about the closure of the "control connection", they are
    // informed in this method; 'parent' is the parent of any message boxes
    void CheckCtrlConClose(HWND parent);

    // determines the path type on the FTP server (simply calls ControlConnection->GetFTPServerPathType())
    CFTPServerPathType GetFTPServerPathType(const char* path);

    // if the "control connection" is closed, offers the user to reopen it
    // (NOTE: does not set the working directory on the server); returns TRUE if the
    // "control connection" is ready for use and in this case also sets
    // SetStartTime() (so subsequent waiting can build on a potential reconnect);
    // 'parent' is the "foreground" window of the thread (after pressing ESC it is used to
    // determine whether ESC was pressed in this window and not in another application; in the main thread it is
    // SalamanderGeneral->GetMsgBoxParent() or a dialog opened by the plugin); 'parent' is
    // also the parent of any error message boxes; in 'reconnected' (if not NULL) it returns
    // TRUE if the connection was restored (the "control connection" was reopened)
    // if 'setStartTimeIfConnected' is FALSE and the connection does not need to be restored, SetStartTime()
    // is not set; 'totalAttemptNum'+'retryMsg' are parameters for StartControlConnection();
    // can only be called from the main thread (currently uses wait windows, etc.)
    BOOL ReconnectIfNeeded(HWND parent, BOOL* reconnected, BOOL setStartTimeIfConnected,
                           int* totalAttemptNum, const char* retryMsg);

    // helper method for ParseListing; only adds the up-dir ("..") to 'dir'
    void AddUpdir(BOOL& err, BOOL& needUpDir, CFTPListingPluginDataInterface* dataIface,
                  TIndirectArray<CSrvTypeColumn>* columns, CSalamanderDirectoryAbstract* dir);

    // attempts to parse the current listing (stored in PathListing) using the parser from 'serverType'
    // (cannot be NULL); 'isVMS' is TRUE if the listing comes from VMS; if parsing succeeds,
    // returns TRUE and provides allocated listing data in 'dir'+'pluginData' (if they are not NULL);
    // if 'findName' is not NULL, searches for that name in the listing ('caseSensitive' is TRUE/FALSE depending on
    // whether strcmp/StrICmp should be used) and reports whether it exists as a file (returns TRUE in 'fileExists')
    // or as a directory (returns TRUE in 'dirExists'); if 'findName' is NULL, parameters
    // 'caseSensitive'+'fileExists'+'dirExists' are ignored; returns FALSE on error, and if the error is
    // lack of memory it returns TRUE in 'lowMem' (must not be NULL)
    BOOL ParseListing(CSalamanderDirectoryAbstract* dir, CPluginDataInterfaceAbstract** pluginData,
                      CServerType* serverType, BOOL* lowMem, BOOL isVMS, const char* findName,
                      BOOL caseSensitive, BOOL* fileExists, BOOL* dirExists);

    void SetNextRefreshCanUseOldListing(BOOL b) { NextRefreshCanUseOldListing = b; }

    // sets the "check marks" according to the current TransferMode value in the x-th
    // ('submenuNumber'-th) submenu of the menu 'menu'
    void SetTransferModeCheckMarksInSubMenu(HMENU menu, int submenuNumber);

    // sets TransferMode based on which command ('cmd') in the "Transfer Mode"
    // context submenu the user selected
    void SetTransferModeByMenuCmd(int cmd);

    // sets TransferMode based on which command ('id') in the "Transfer Mode"
    // plugin menu submenu the user selected
    void SetTransferModeByMenuCmd2(int id);

    // returns the state of the command ('id') in the "Transfer Mode" submenu of the plugin menu
    // according to the current value of TransferMode
    DWORD GetTransferModeCmdState(int id);

    // sets the "check mark" for the "List Hidden Files (Unix)" item according to the current value
    // of the list command into the menu 'menu'
    void SetListHiddenFilesCheckInMenu(HMENU menu);

    // enables the "Show Certificate" item depending on whether it is an FTPS connection or not
    void SetShowCertStateInMenu(HMENU menu);

    // called when the user clicks List Hidden Files (Unix) in the menu - if
    // "LIST -a" is used, it switches back to the original listing command or "LIST";
    // additionally displays a message box with a hint on how to set the List Command in bookmarks
    void ToggleListHiddenFiles(HWND parent);

    // simply calls IsListCommandLIST_a() on the control connection
    BOOL IsListCommandLIST_a();

    // opens the operation progress window and runs it in the active "control connection"
    // (the items are processed in a worker created based on the active control connection
    // in the panel (when called, ControlConnection is guaranteed to be not NULL));
    // 'parent' is the "foreground" window of the thread (after pressing ESC it is used to
    // determine whether ESC was pressed in this window and not in another application; in the main thread it is
    // SalamanderGeneral->GetMsgBoxParent() or a dialog opened by the plugin); returns TRUE
    // when the operation starts successfully (otherwise an error occurs and the operation is cancelled)
    BOOL RunOperation(HWND parent, int operUID, CFTPOperation* oper, HWND dropTargetWnd);

    // returns TRUE if the "control connection" has the UID 'controlConUID'
    BOOL ContainsConWithUID(int controlConUID);

    // simply forwards the call to ControlConnection->GetConnectionFromWorker
    void GetConnectionFromWorker(CFTPWorker* workerWithCon);

    // simply checks ControlConnection != NULL and calls ControlConnection->ActivateWelcomeMsg()
    // can only be called in the main thread
    void ActivateWelcomeMsg();

    // simply checks whether ControlConnection->GetEncryptControlConnection() == 1
    BOOL IsFTPS();

    // iterates over other open FS instances and if this is the first one connecting to 'host'+'port'
    // as 'user', deletes all listings for 'host'+'port'+'user' from the listing cache
    void ClearHostFromListingCacheIfFirstCon(const char* host, int port, const char* user);

    // determines whether this FS connects to 'host'+'port' as 'user'
    BOOL ContainsHost(const char* host, int port, const char* user);

    // methods inherited from CPluginFSInterfaceAbstract:
    virtual BOOL WINAPI GetCurrentPath(char* userPart);
    virtual BOOL WINAPI GetFullName(CFileData& file, int isDir, char* buf, int bufSize);
    virtual BOOL WINAPI GetFullFSPath(HWND parent, const char* fsName, char* path, int pathSize, BOOL& success);
    virtual BOOL WINAPI GetRootPath(char* userPart);

    virtual BOOL WINAPI IsCurrentPath(int currentFSNameIndex, int fsNameIndex, const char* userPart);
    virtual BOOL WINAPI IsOurPath(int currentFSNameIndex, int fsNameIndex, const char* userPart);

    virtual BOOL WINAPI ChangePath(int currentFSNameIndex, char* fsName, int fsNameIndex,
                                   const char* userPart, char* cutFileName, BOOL* pathWasCut,
                                   BOOL forceRefresh, int mode);
    virtual BOOL WINAPI ListCurrentPath(CSalamanderDirectoryAbstract* dir,
                                        CPluginDataInterfaceAbstract*& pluginData,
                                        int& iconsType, BOOL forceRefresh);

    virtual BOOL WINAPI TryCloseOrDetach(BOOL forceClose, BOOL canDetach, BOOL& detach, int reason);

    virtual void WINAPI Event(int event, DWORD param);

    virtual void WINAPI ReleaseObject(HWND parent);

    virtual DWORD WINAPI GetSupportedServices();

    virtual BOOL WINAPI GetChangeDriveOrDisconnectItem(const char* fsName, char*& title, HICON& icon, BOOL& destroyIcon);
    virtual HICON WINAPI GetFSIcon(BOOL& destroyIcon);
    virtual void WINAPI GetDropEffect(const char* srcFSPath, const char* tgtFSPath,
                                      DWORD allowedEffects, DWORD keyState,
                                      DWORD* dropEffect) {}
    virtual void WINAPI GetFSFreeSpace(CQuadWord* retValue) { *retValue = CQuadWord(0, 0); }
    virtual BOOL WINAPI GetNextDirectoryLineHotPath(const char* text, int pathLen, int& offset);
    virtual void WINAPI CompleteDirectoryLineHotPath(char* path, int pathBufSize);
    virtual BOOL WINAPI GetPathForMainWindowTitle(const char* fsName, int mode, char* buf, int bufSize);
    virtual void WINAPI ShowInfoDialog(const char* fsName, HWND parent) {}
    virtual BOOL WINAPI ExecuteCommandLine(HWND parent, char* command, int& selFrom, int& selTo) { return FALSE; }
    virtual BOOL WINAPI QuickRename(const char* fsName, int mode, HWND parent, CFileData& file, BOOL isDir,
                                    char* newName, BOOL& cancel);
    virtual void WINAPI AcceptChangeOnPathNotification(const char* fsName, const char* path, BOOL includingSubdirs);
    virtual BOOL WINAPI CreateDir(const char* fsName, int mode, HWND parent, char* newName, BOOL& cancel);
    virtual void WINAPI ViewFile(const char* fsName, HWND parent,
                                 CSalamanderForViewFileOnFSAbstract* salamander,
                                 CFileData& file);
    virtual BOOL WINAPI Delete(const char* fsName, int mode, HWND parent, int panel,
                               int selectedFiles, int selectedDirs, BOOL& cancelOrError);
    virtual BOOL WINAPI CopyOrMoveFromFS(BOOL copy, int mode, const char* fsName, HWND parent,
                                         int panel, int selectedFiles, int selectedDirs,
                                         char* targetPath, BOOL& operationMask,
                                         BOOL& cancelOrHandlePath, HWND dropTarget);
    virtual BOOL WINAPI CopyOrMoveFromDiskToFS(BOOL copy, int mode, const char* fsName, HWND parent,
                                               const char* sourcePath, SalEnumSelection2 next,
                                               void* nextParam, int sourceFiles, int sourceDirs,
                                               char* targetPath, BOOL* invalidPathOrCancel);
    virtual BOOL WINAPI ChangeAttributes(const char* fsName, HWND parent, int panel,
                                         int selectedFiles, int selectedDirs);
    virtual void WINAPI ShowProperties(const char* fsName, HWND parent, int panel,
                                       int selectedFiles, int selectedDirs) {}
    virtual void WINAPI ContextMenu(const char* fsName, HWND parent, int menuX, int menuY, int type,
                                    int panel, int selectedFiles, int selectedDirs);
    virtual BOOL WINAPI OpenFindDialog(const char* fsName, int panel) { return FALSE; }
    virtual void WINAPI OpenActiveFolder(const char* fsName, HWND parent) {}
    virtual void WINAPI GetAllowedDropEffects(int mode, const char* tgtFSPath, DWORD* allowedEffects) {}
    virtual BOOL WINAPI HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plResult) { return FALSE; }
    virtual BOOL WINAPI GetNoItemsInPanelText(char* textBuf, int textBufSize) { return FALSE; }
    virtual void WINAPI ShowSecurityInfo(HWND parent);

    friend CPluginInterfaceForFS;
};

// array with all open FS instances (use only from the main thread - unsynchronized)
extern TIndirectArray<CPluginFSInterface> FTPConnections;

// data interface for the raw listing in the panel
extern CSimpleListPluginDataInterface SimpleListPluginDataInterface;
